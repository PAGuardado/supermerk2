// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __assign, __awaiter, __extends, __generator } from "tslib";
import { isTokenCredential, isNode, getDefaultProxySettings, URLBuilder } from "@azure/core-http";
import { SpanStatusCode } from "@azure/core-tracing";
import { Messages, MessageId, Queue } from "./generated/src/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import { appendToURLPath, extractConnectionStringParts, isIpEndpointStyle, truncatedISO8061Date, getStorageClientContext, appendToURLQuery } from "./utils/utils.common";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { createSpan } from "./utils/tracing";
import { generateQueueSASQueryParameters } from "./QueueSASSignatureValues";
/**
 * A QueueClient represents a URL to an Azure Storage Queue's messages allowing you to manipulate its messages.
 */
var QueueClient = /** @class */ (function (_super) {
    __extends(QueueClient, _super);
    function QueueClient(urlOrConnectionString, credentialOrPipelineOrQueueName, options) {
        var _this = this;
        options = options || {};
        var pipeline;
        var url;
        if (credentialOrPipelineOrQueueName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrQueueName;
        }
        else if ((isNode && credentialOrPipelineOrQueueName instanceof StorageSharedKeyCredential) ||
            credentialOrPipelineOrQueueName instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipelineOrQueueName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrQueueName, options);
        }
        else if (!credentialOrPipelineOrQueueName &&
            typeof credentialOrPipelineOrQueueName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            // The second paramter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrQueueName &&
            typeof credentialOrPipelineOrQueueName === "string") {
            // (connectionString: string, containerName: string, queueName: string, options?: StoragePipelineOptions)
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var queueName = credentialOrPipelineOrQueueName;
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, queueName);
                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                var queueName = credentialOrPipelineOrQueueName;
                url = appendToURLPath(extractedCreds.url, queueName) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for queueName parameter");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this._name = _this.getQueueNameFromUrl();
        _this.queueContext = new Queue(_this.storageClientContext);
        // MessagesContext
        // Build the url with "messages"
        var partsOfUrl = _this.url.split("?");
        _this._messagesUrl = partsOfUrl[1]
            ? appendToURLPath(partsOfUrl[0], "messages") + "?" + partsOfUrl[1]
            : appendToURLPath(partsOfUrl[0], "messages");
        _this.messagesContext = new Messages(getStorageClientContext(_this._messagesUrl, _this.pipeline));
        return _this;
    }
    Object.defineProperty(QueueClient.prototype, "name", {
        /**
         * The name of the queue.
         */
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    QueueClient.prototype.getMessageIdContext = function (messageId) {
        // Build the url with messageId
        var partsOfUrl = this._messagesUrl.split("?");
        var urlWithMessageId = partsOfUrl[1]
            ? appendToURLPath(partsOfUrl[0], messageId) + "?" + partsOfUrl[1]
            : appendToURLPath(partsOfUrl[0], messageId);
        return new MessageId(getStorageClientContext(urlWithMessageId, this.pipeline));
    };
    /**
     * Creates a new queue under the specified account.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-queue4
     *
     * @param options - Options to Queue create operation.
     * @returns Response data for the Queue create operation.
     *
     * Example usage:
     *
     * ```js
     * const queueClient = queueServiceClient.getQueueClient("<new queue name>");
     * const createQueueResponse = await queueClient.create();
     * ```
     */
    QueueClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-create", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.queueContext.create(__assign(__assign({}, updatedOptions), { abortSignal: options.abortSignal }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new queue under the specified account if it doesn't already exist.
     * If the queue already exists, it is not changed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-queue4
     *
     * @param options -
     */
    QueueClient.prototype.createIfNotExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, response, e_2;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("QueueClient-createIfNotExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.create(updatedOptions)];
                    case 2:
                        response = _d.sent();
                        // When a queue with the specified name already exists, the Queue service checks the metadata associated with the existing queue.
                        // If the existing metadata is identical to the metadata specified on the Create Queue request, status code 204 (No Content) is returned.
                        // If the existing metadata does not match, the operation fails and status code 409 (Conflict) is returned.
                        if (response._response.status == 204) {
                            return [2 /*return*/, __assign({ succeeded: false }, response)];
                        }
                        return [2 /*return*/, __assign({ succeeded: true }, response)];
                    case 3:
                        e_2 = _d.sent();
                        if (((_a = e_2.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "QueueAlreadyExists") {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when creating a queue only if it does not already exist."
                            });
                            return [2 /*return*/, __assign(__assign({ succeeded: false }, (_b = e_2.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_2.response })];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Deletes the specified queue permanently if it exists.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-queue3
     *
     * @param options -
     */
    QueueClient.prototype.deleteIfExists = function (options) {
        var _a, _b;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _c, span, updatedOptions, res, e_3;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = createSpan("QueueClient-deleteIfExists", options), span = _c.span, updatedOptions = _c.updatedOptions;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.delete(updatedOptions)];
                    case 2:
                        res = _d.sent();
                        return [2 /*return*/, __assign({ succeeded: true }, res)];
                    case 3:
                        e_3 = _d.sent();
                        if (((_a = e_3.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "QueueNotFound") {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when deleting a queue only if it exists."
                            });
                            return [2 /*return*/, __assign(__assign({ succeeded: false }, (_b = e_3.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e_3.response })];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Deletes the specified queue permanently.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-queue3
     *
     * @param options - Options to Queue delete operation.
     * @returns Response data for the Queue delete operation.
     *
     * Example usage:
     *
     * ```js
     * const deleteQueueResponse = await queueClient.delete();
     * console.log(
     *   "Delete queue successfully, service assigned request Id:", deleteQueueResponse.requestId
     * );
     * ```
     */
    QueueClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-delete", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.queueContext.delete({
                                abortSignal: options.abortSignal,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns true if the specified queue exists; false otherwise.
     *
     * NOTE: use this function with care since an existing queue might be deleted by other clients or
     * applications. Vice versa new queues might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    QueueClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-exists", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_5 = _b.sent();
                        if (e_5.statusCode === 404) {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: "Expected exception when checking queue existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets all user-defined metadata and system properties for the specified
     * queue. Metadata is associated with the queue as name-values pairs.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-queue-metadata
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listQueues` method of {@link QueueServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @param options - Options to Queue get properties operation.
     * @returns Response data for the Queue get properties operation.
     */
    QueueClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-getProperties", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.queueContext.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified queue.
     *
     * If no option provided, or no metadata defined in the option parameter, the queue
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-queue-metadata
     *
     * @param metadata - If no metadata provided, all existing metadata will be removed.
     * @param options - Options to Queue set metadata operation.
     * @returns Response data for the Queue set metadata operation.
     */
    QueueClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_7;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-setMetadata", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.queueContext.setMetadata({
                                abortSignal: options.abortSignal,
                                metadata: metadata,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets details about any stored access policies specified on the queue that may be used with Shared Access Signatures.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-queue-acl
     *
     * @param options - Options to Queue get access policy operation.
     * @returns Response data for the Queue get access policy operation.
     */
    QueueClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, res, _i, response_1, identifier, accessPolicy, e_8;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-getAccessPolicy", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.queueContext.getAccessPolicy({
                                abortSignal: options.abortSignal,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            requestId: response.requestId,
                            clientRequestId: response.clientRequestId,
                            signedIdentifiers: [],
                            version: response.version,
                            errorCode: response.errorCode
                        };
                        for (_i = 0, response_1 = response; _i < response_1.length; _i++) {
                            identifier = response_1[_i];
                            accessPolicy = undefined;
                            if (identifier.accessPolicy) {
                                accessPolicy = {
                                    permissions: identifier.accessPolicy.permissions
                                };
                                if (identifier.accessPolicy.expiresOn) {
                                    accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                                }
                                if (identifier.accessPolicy.startsOn) {
                                    accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                                }
                            }
                            res.signedIdentifiers.push({
                                accessPolicy: accessPolicy,
                                id: identifier.id
                            });
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets stored access policies for the queue that may be used with Shared Access Signatures.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-queue-acl
     *
     * @param queueAcl -
     * @param options - Options to Queue set access policy operation.
     * @returns Response data for the Queue set access policy operation.
     */
    QueueClient.prototype.setAccessPolicy = function (queueAcl, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, acl, _i, _b, identifier, e_9;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = createSpan("QueueClient-setAccessPolicy", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, 4, 5]);
                        acl = [];
                        for (_i = 0, _b = queueAcl || []; _i < _b.length; _i++) {
                            identifier = _b[_i];
                            acl.push({
                                accessPolicy: {
                                    expiresOn: identifier.accessPolicy.expiresOn
                                        ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)
                                        : undefined,
                                    permissions: identifier.accessPolicy.permissions,
                                    startsOn: identifier.accessPolicy.startsOn
                                        ? truncatedISO8061Date(identifier.accessPolicy.startsOn)
                                        : undefined
                                },
                                id: identifier.id
                            });
                        }
                        return [4 /*yield*/, this.queueContext.setAccessPolicy({
                                abortSignal: options.abortSignal,
                                queueAcl: acl,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2: return [2 /*return*/, _c.sent()];
                    case 3:
                        e_9 = _c.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Clear deletes all messages from a queue.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/clear-messages
     *
     * @param options - Options to clear messages operation.
     * @returns Response data for the clear messages operation.
     */
    QueueClient.prototype.clearMessages = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_10;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-clearMessages", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.messagesContext.clear({
                                abortSignal: options.abortSignal,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_10 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_10.message
                        });
                        throw e_10;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * sendMessage adds a new message to the back of a queue. The visibility timeout specifies how long
     * the message should be invisible to Dequeue and Peek operations.
     * The message content is up to 64KB in size, and must be in a format that can be included in an XML request with UTF-8 encoding.
     * To include markup in the message, the contents of the message must either be XML-escaped or Base64-encode.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-message
     *
     * @param messageText - Text of the message to send
     * @param options - Options to send messages operation.
     * @returns Response data for the send messages operation.
     *
     * Example usage:
     *
     * ```js
     * const sendMessageResponse = await queueClient.sendMessage("Hello World!");
     * console.log(
     *   "Sent message successfully, service assigned message Id:", sendMessageResponse.messageId,
     *   "service assigned request Id:", sendMessageResponse.requestId
     * );
     * ```
     */
    QueueClient.prototype.sendMessage = function (messageText, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, item, e_11;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-sendMessage", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.messagesContext.enqueue({
                                messageText: messageText
                            }, updatedOptions)];
                    case 2:
                        response = _b.sent();
                        item = response[0];
                        return [2 /*return*/, {
                                _response: response._response,
                                date: response.date,
                                requestId: response.requestId,
                                clientRequestId: response.clientRequestId,
                                version: response.version,
                                errorCode: response.errorCode,
                                messageId: item.messageId,
                                popReceipt: item.popReceipt,
                                nextVisibleOn: item.nextVisibleOn,
                                insertedOn: item.insertedOn,
                                expiresOn: item.expiresOn
                            }];
                    case 3:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_11.message
                        });
                        throw e_11;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * receiveMessages retrieves one or more messages from the front of the queue.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-messages
     *
     * @param options - Options to receive messages operation.
     * @returns Response data for the receive messages operation.
     *
     * Example usage:
     *
     * ```js
     * const response = await queueClient.receiveMessages();
     * if (response.receivedMessageItems.length == 1) {
     *   const receivedMessageItem = response.receivedMessageItems[0];
     *   console.log("Processing & deleting message with content:", receivedMessageItem.messageText);
     *   const deleteMessageResponse = await queueClient.deleteMessage(
     *     receivedMessageItem.messageId,
     *     receivedMessageItem.popReceipt
     *   );
     *   console.log(
     *     "Delete message successfully, service assigned request Id:",
     *     deleteMessageResponse.requestId
     *   );
     * }
     * ```
     */
    QueueClient.prototype.receiveMessages = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, res, _i, response_2, item, e_12;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-receiveMessages", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.messagesContext.dequeue(updatedOptions)];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            requestId: response.requestId,
                            clientRequestId: response.clientRequestId,
                            receivedMessageItems: [],
                            version: response.version,
                            errorCode: response.errorCode
                        };
                        for (_i = 0, response_2 = response; _i < response_2.length; _i++) {
                            item = response_2[_i];
                            res.receivedMessageItems.push(item);
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_12 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_12.message
                        });
                        throw e_12;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * peekMessages retrieves one or more messages from the front of the queue but does not alter the visibility of the message.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/peek-messages
     *
     * @param options - Options to peek messages operation.
     * @returns Response data for the peek messages operation.
     *
     * Example usage:
     *
     * ```js
     * const peekMessagesResponse = await queueClient.peekMessages();
     * console.log("The peeked message is:", peekMessagesResponse.peekedMessageItems[0].messageText);
     * ```
     */
    QueueClient.prototype.peekMessages = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, response, res, _i, response_3, item, e_13;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-peekMessages", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.messagesContext.peek(updatedOptions)];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            requestId: response.requestId,
                            clientRequestId: response.clientRequestId,
                            peekedMessageItems: [],
                            version: response.version,
                            errorCode: response.errorCode
                        };
                        for (_i = 0, response_3 = response; _i < response_3.length; _i++) {
                            item = response_3[_i];
                            res.peekedMessageItems.push(item);
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_13 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_13.message
                        });
                        throw e_13;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * deleteMessage permanently removes the specified message from its queue.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-message2
     *
     * @param messageId - Id of the message.
     * @param popReceipt - A valid pop receipt value returned from an earlier call to the receive messages or update message operation.
     * @param options - Options to delete message operation.
     * @returns Response data for the delete message operation.
     */
    QueueClient.prototype.deleteMessage = function (messageId, popReceipt, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, e_14;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-deleteMessage", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getMessageIdContext(messageId).delete(popReceipt, {
                                abortSignal: options.abortSignal,
                                tracingOptions: updatedOptions.tracingOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_14 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_14.message
                        });
                        throw e_14;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update changes a message's visibility timeout and contents.
     * The message content is up to 64KB in size, and must be in a format that can be included in an XML request with UTF-8 encoding.
     * To include markup in the message, the contents of the message must either be XML-escaped or Base64-encode.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/update-message
     *
     * @param messageId - Id of the message
     * @param popReceipt - A valid pop receipt value returned from an earlier call to the receive messages or update message operation.
     * @param message - Message to update. If this parameter is undefined, then the content of the message won't be updated.
     * @param visibilityTimeout - Specifies the new visibility timeout value, in seconds,
     *                                   relative to server time. The new value must be larger than or equal to 0,
     *                                   and cannot be larger than 7 days. The visibility timeout of a message cannot
     *                                   be set to a value later than the expiry time.
     *                                   A message can be updated until it has been deleted or has expired.
     * @param options - Options to update message operation.
     * @returns Response data for the update message operation.
     */
    QueueClient.prototype.updateMessage = function (messageId, popReceipt, message, visibilityTimeout, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, updatedOptions, queueMessage, e_15;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueClient-updateMessage", options), span = _a.span, updatedOptions = _a.updatedOptions;
                        queueMessage = undefined;
                        if (message !== undefined) {
                            queueMessage = { messageText: message };
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getMessageIdContext(messageId).update(popReceipt, visibilityTimeout || 0, {
                                abortSignal: options.abortSignal,
                                tracingOptions: updatedOptions.tracingOptions,
                                queueMessage: queueMessage
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_15 = _b.sent();
                        span.setStatus({
                            code: SpanStatusCode.ERROR,
                            message: e_15.message
                        });
                        throw e_15;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    QueueClient.prototype.getQueueNameFromUrl = function () {
        var queueName;
        try {
            //  URL may look like the following
            // "https://myaccount.queue.core.windows.net/myqueue?sasString".
            // "https://myaccount.queue.core.windows.net/myqueue".
            // IPv4/IPv6 address hosts, Endpoints - `http://127.0.0.1:10001/devstoreaccount1/myqueue`
            // http://localhost:10001/devstoreaccount1/queuename
            var parsedUrl = URLBuilder.parse(this.url);
            if (parsedUrl.getHost().split(".")[1] === "queue") {
                // "https://myaccount.queue.core.windows.net/queuename".
                // .getPath() -> /queuename
                queueName = parsedUrl.getPath().split("/")[1];
            }
            else if (isIpEndpointStyle(parsedUrl)) {
                // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/queuename
                // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/queuename
                // .getPath() -> /devstoreaccount1/queuename
                queueName = parsedUrl.getPath().split("/")[2];
            }
            else {
                // "https://customdomain.com/queuename".
                // .getPath() -> /queuename
                queueName = parsedUrl.getPath().split("/")[1];
            }
            if (!queueName) {
                throw new Error("Provided queueName is invalid.");
            }
            return queueName;
        }
        catch (error) {
            throw new Error("Unable to extract queueName with provided information.");
        }
    };
    /**
     * Only available for QueueClient constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    QueueClient.prototype.generateSasUrl = function (options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        var sas = generateQueueSASQueryParameters(__assign({ queueName: this.name }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    };
    return QueueClient;
}(StorageClient));
export { QueueClient };
//# sourceMappingURL=QueueClient.js.map